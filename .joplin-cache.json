{
  "note": [
    {
      "id": "ed4ba89c834c4949949a3997e44344c0",
      "title": "使用 frp 把内网服务暴露到公网",
      "body": "## frp 介绍\n\nfrp 是一个专注于内网穿透的反向代理工具，支持 TCP、UDP、HTTP、HTTPS 等多种协议。可以将内网服务通过具有公网 IP 节点的中转暴露到公网。\n\n软件安装以及自建服务端可以去[官方文档](https://gofrp.org/docs/)查看\n\n## 免费平台推荐\n\n1. [Sakura Frp](https://www.natfrp.com/)（体验好，有国内节点，需要注册账号，建立 http 通道绑定的域名需要备案）\n2. [免费 FRP 内网穿透](https://freefrp.net/docs)（体验略逊于上面，但无需注册，建立 http 通道需要自己的域名，无需备案）\n\n## 配置示例\n\n### 通过 SSH 访问内网机器\n\n```ini\n[common]\nserver_addr = frp.freefrp.net\nserver_port = 7000\ntoken = freefrp.net\n\n[ssh_484939d2_tcp]\ntype = tcp\nlocal_ip = 127.0.0.1 # 自己机器的ip，本机部署就是127.0.0.1\nlocal_port = 22 # 本地提供服务的ip地址\nremote_port = 39317 # 映射到公网的哪个端口，（启动后如果无法访问就换个端口\n```\n\n然后可以使用`ssh ssh://root@frp.freefrp.net:39317`连接到内网设备\n\n### 通过自定义域名访问内网的 Web 服务\n\n```ini\n[common]\nserver_addr = frp.freefrp.net\nserver_port = 7000\ntoken = freefrp.net\n\n[test_your_domain_http]\ntype = http\nlocal_ip = 127.0.0.1\nlocal_port = 8080\ncustom_domains = test.your.domain\nsubdomain = test\n```\n\n然后可以使用`http://test.your.domain`访问你内网部署的网站\n\n更多示例：[示例 | frp](https://gofrp.org/docs/examples/)\n",
      "createdTime": 1671542019779,
      "updatedTime": 1671544781184,
      "resources": [],
      "tags": [
        {
          "id": "01cfdfe318254b2e9fc768b1c2d7d60d",
          "title": "frp",
          "parent_id": ""
        },
        {
          "id": "bc0486755a3b4115821089dff75175d0",
          "title": "blog",
          "parent_id": ""
        }
      ]
    },
    {
      "id": "510ae53b6f6e4379a6ee784c0bbe3231",
      "title": "使用 nvm 快速安装和使用不同版本的 node",
      "body": "`nvm`的全名是 Node Version Manager[^1]，是一个 node.js 的版本管理器，可以帮助用户通过命令行快速安装和使用不同版本的 node。nvm 可以在任何兼容 POSIX 的 shell（sh、dash、ksh、zsh、bash）上工作，尤其是在 unix、macOS 和 windows WSL。\n\n## 安装\n\n```bash\ncurl -o- https://cdn.jsdelivr.net/gh/nvm-sh/nvm/install.sh | bash\n```\n\n请在安装后执行一下`nvm`检查是否成功，该安装脚本会尝试自动处理 `~/.bashrc`，如果没有找到`nvm`命令，可以手动在 shell 的用户配置文件添加如下内容（`zsh`对应的是`~/.zshrc`，其他 shell 请自行查询用户配置位置）\n\n```bash\nexport NVM_DIR=\"$HOME/.nvm\"\n[ -s \"$NVM_DIR/nvm.sh\" ] && \\. \"$NVM_DIR/nvm.sh\"  # This loads nvm\n```\n\n## 简单使用\n\n```bash\nnvm install --lts # 下载最新的LTS版本\nnvm use --lts # 使用最新的LTS版本\nnvm alias default v16.14.2 # 设置最新的LTS版本为默认（此时最新的LTS版本为v16.14.2）\n```\n\n然后检查一下配置是否生效\n\n```bash\n$ which npm\n/home/idea/.nvm/versions/node/v16.14.2/bin/npm\n$ which node\n/home/idea/.nvm/versions/node/v16.14.2/bin/node\n```\n\n## 更改 npmmirror 中国镜像站\n\n```bash\nnpm config set registry https://registry.npmmirror.com\n```\n\n更多使用姿势请自行搜索\n\n[^1]: https://github.com/nvm-sh/nvm\n",
      "createdTime": 1650631560000,
      "updatedTime": 1671541380000,
      "resources": [],
      "tags": [
        {
          "id": "01557b83e8dc47db9fa754c22b9e6776",
          "title": "node",
          "parent_id": ""
        },
        {
          "id": "bc0486755a3b4115821089dff75175d0",
          "title": "blog",
          "parent_id": ""
        },
        {
          "id": "e6d44e77de66458086425aee4097d6ca",
          "title": "npm",
          "parent_id": ""
        }
      ]
    },
    {
      "id": "a7b61f3fa1934555a3a519c34a61cd75",
      "title": "使用 davfs2 挂载 webdav",
      "body": "首先安装好 davfs2 软件包\n\n## 配置 davfs2\n\n- 编辑 /etc/davfs2/davfs2.conf 取消以下项的注释并更改值\n\n```bash\nignore_dav_header 1\nuse_locks 0\n```\n\n- 配置用户名/密码\n\n编辑 /etc/davfs2/secrets 末尾添加\n\n```bash\nhttps://seto.teracloud.jp/dav/ <username> <secret>\n# 也可以有子目录\nhttps://seto.teracloud.jp/dav/dir1/ <username> <secret>\nhttps://seto.teracloud.jp/dav/dir2/ <username> <secret>\n```\n\n## 手动挂载\n\n```bash\n#创建挂载路径\nmkdir /webdav\n#手动挂载\nmount -t davfs https://seto.teracloud.jp/dav/dir1/ /webdav/dir1/\n# 卸载\numount /webdav/dir1/\n```\n\n手动挂载测试过没问题后可以配置开机自动挂载\n\n## 自动挂载\n\n编辑 /etc/fstab 末尾添加\n\n```bash\nhttps://seto.teracloud.jp/dav/dir1/ /path/to/dir1/ davfs rw,user,sync,noauto,uid=1000,_netdev 0 0\n```\n\n编辑`etc/systemd/system/mount-webdav.service`\n\n```bash\n[Unit]\n# 服务名称，可自定义Description=Mount WebDAV Service (KeePass)\nAfter = network.target syslog.target\nWants = network.target\n\n[Service]\nType = oneshot\nExecStart = bash -c 'for i in {1..15}; do if ping -c 1 seto.teracloud.jp; then mount /path/to/dir1/; break; else sleep 1; fi; done'\nExecStop = umount /path/to/dir1/\nRemainAfterExit = true\n\n[Install]\nWantedBy = multi-user.target\n```\n\n然后执行下面命令\n\n```bash\nsystemctl enable --now keepass-webdav.service\n```\n",
      "createdTime": 1659787200000,
      "updatedTime": 1671453600000,
      "resources": [],
      "tags": [
        {
          "id": "6476ae726bf34e28b8f9f5e3345d7af0",
          "title": "linux",
          "parent_id": ""
        },
        {
          "id": "af939074a9e34a099426f8eb244a74b9",
          "title": "webdav",
          "parent_id": ""
        },
        {
          "id": "bc0486755a3b4115821089dff75175d0",
          "title": "blog",
          "parent_id": ""
        }
      ]
    },
    {
      "id": "ce1c7e8fd2f349fa8516d01e2af4fc00",
      "title": "linux 上几种睡眠模式比较",
      "body": "```bash\nsystemctl suspend                 -- Suspend the system\nsystemctl hibernate     -- Hibernate the system\nsystemctl suspend-then-hibernate  -- Suspend the system for a period of time, and then hibernate it\nsystemctl hybrid-sleep  -- Hibernate and suspend the system\n```\n\n## suspend\n\n普通的挂起（或者说睡眠），机器能以最快的速度被唤醒。不建议在笔记本不插电时使用，容易睡死(电池耗尽后丢失工作状态)。\n\n## hibernate\n\n普通的休眠，约等于完全关机，但会保留上次的内存状态到硬盘内，唤醒后再恢复。速度稍慢，好处是不用担心睡死（毕竟已经“完全关机”了:joy_cat:）。\n\n## suspend-then-hibernate\n\n先挂起，经过一段时间后系统自动唤醒并执行休眠操作。\n\n但默认的等待时间一般都比较长，（文档里说是 120min，`/etc/systemd/sleep.conf`里的默认配置写的是 180min），电池不给力的话，仍有睡死的风险，如使用此模式建议根据笔记本情况以及自己的需求设定一个较短的时间。\n\n## hybrid-sleep\n\n混合睡眠，suspend 的同时也把内存状态备份到硬盘，睡眠速度比 suspend 稍慢，唤醒速度大差不差，可以防止睡死。\n\n我起初以为它的效果只是 suspend 的同时也把内存状态备份到硬盘以避免睡死，但在实际使用时发现我的笔记本在 suspend 时仍会发热（而且发热量很可观，几乎比省电模式下空载还热了，耗电估计也小不了），但 hybrid-sleep 时几乎没有发热，我觉得它应该做了更多的处理。不排除 suspend 在我的本子上没有正常工作这个可能\n\n> 我发现我的笔记本在 suspend 时仍会发热（而且发热量很可观，几乎比省电模式下空载还热了，耗电估计也小不了），但 hybrid-sleep 时几乎没有发热（和在 Windows 11 下睡眠的表现差不多）。\n> suspend 是普通的挂起，hybrid-sleep 是混合睡眠，从文档里的的介绍来看混合睡眠只是比普通的挂起多了个保存内存状态到硬盘的操作，按理说它俩的功耗表现应该是一样的啊，是 hybrid-sleep 在控制功耗方面做了更多的处理，还是 suspend 在我的本子上没有正常工作呢？\n> <https://forum.suse.org.cn/t/topic/15224>\n\n## 解决\n\n```bash\n# /etc/systemd/sleep.conf\n[Sleep]\n#AllowSuspend=yes\n#AllowHibernation=yes\n#AllowSuspendThenHibernate=yes\n#AllowHybridSleep=yes\n#SuspendMode=\n#SuspendState=mem standby freeze\n#HibernateMode=platform shutdown\n#HibernateState=disk\n#HybridSleepMode=suspend platform shutdown\n#HybridSleepState=disk\n#HibernateDelaySec=180min\n\n# Disable useless items\nAllowHibernation=no\nAllowSuspendThenHibernate=no\n# Configure suspend as hybrid-sleep\nSuspendMode=suspend platform shutdown\nSuspendState=disk\n```\n",
      "createdTime": 1670672789090,
      "updatedTime": 1671350378831,
      "resources": [],
      "tags": [
        {
          "id": "6476ae726bf34e28b8f9f5e3345d7af0",
          "title": "linux",
          "parent_id": ""
        },
        {
          "id": "bc0486755a3b4115821089dff75175d0",
          "title": "blog",
          "parent_id": ""
        }
      ]
    },
    {
      "id": "eca39d14dbf84484939d280766dd6681",
      "title": "再谈 git 与 ssh 配置",
      "body": "## 说在前面\n\n对于 GitHub，要代理 HTTP 协议的克隆链接，直接执行下面命令（注意代理地址）：\n\n```bash\ngit config --global http.https://github.com.proxy socks5h://127.0.0.1:7890\n# socks5h://表示主机名由 SOCKS 服务器解析\n```\n\n下面说一下几种 SSH 协议的克隆链接\n\n## Part1 SSH 协议只改端口不配置代理\n\n```bash\ngit@github.com:waleslau/dotfiles.git\nssh://git@ssh.github.com:443/waleslau/dotfiles.git\n```\n\n后面那种链接就是直接在连接里指定了 ssh 的端口。如果因某些原因无法访问 22 端口，有两个选择，一是使用后面那种链接，二是在 `~/.ssh/config` 内添加如下配置，两种方式是等价的\n\n```bash\nHost github.com\n        Hostname ssh.github.com\n        Port 443\n        User git\n```\n\n上面配置的内容的意思大概就是当访问`git@github.com`时自动翻译成`git@ssh.github.com:443`\n\n## Part2 SSH 协议加上代理的配置\n\n由于众所周知的原因，只是改到 443 端口可能不够，需要走代理。还是分两种情况讨论：\n\n对于`git@github.com:waleslau/dotfiles.git` 这样的链接，要让它走代理，需要编辑配置文件`~/.ssh/config`添加下面内容\n\n```bash\nHost github.com\n       User git\n       ProxyCommand \"C:\\Program Files\\Git\\mingw64\\bin\\connect.exe\" -S 127.0.0.1:7890 %h %p\n```\n\n## 以下内容仅作了解\n\n> 写完才发现下面内容其实有点画蛇添足了，既然都用代理了，改不改 443 端口也就无所谓了，对使用者来讲没有任何区别 🤣\n\n如果你想让`ssh://git@ssh.github.com:443/waleslau/dotfiles.git`这种风格的链接也走代理的话，需要在 Host 后面加上`ssh.github.com`。\n\n```bash\nHost github.com ssh.github.com\n        Hostname ssh.github.com\n        Port 443\n        User git\n        ProxyCommand \"C:\\Program Files\\Git\\mingw64\\bin\\connect.exe\" -S 127.0.0.1:7890 %h %p\n```\n\n## 更多相关内容\n\n- [给 SSH 设置代理](https://blog.oopsky.top/2022/03/ssh-over-proxy/)\n- [突破网络限制访问 GitHub](https://blog.oopsky.top/2022/03/way-to-access-github/)\n",
      "createdTime": 1671342540000,
      "updatedTime": 1671342540000,
      "resources": [],
      "tags": [
        {
          "id": "095da2386f07443ebb0734b02855924e",
          "title": "proxy",
          "parent_id": ""
        },
        {
          "id": "19dd60b67acb4fcf8d864e334d8c8eb7",
          "title": "git",
          "parent_id": ""
        },
        {
          "id": "bc0486755a3b4115821089dff75175d0",
          "title": "blog",
          "parent_id": ""
        },
        {
          "id": "f432ae6d0ac84bd7a6fa93387182c341",
          "title": "ssh",
          "parent_id": ""
        }
      ]
    }
  ],
  "resource": []
}
